AWSTemplateFormatVersion: '2010-09-09'
Description: 'AllSenses AI Guardian - Production Ready Deployment'

Parameters:
  NotificationEmail:
    Type: String
    Default: <REDACTED_EMAIL>
    Description: Email for emergency notifications
    AllowedPattern: '^[^\s@]+@[^\s@]+\.[^\s@]+$'

Resources:
  # IAM Role for Lambda with minimal permissions
  AllSensesLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'AllSenses-Lambda-${AWS::AccountId}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AllSensesPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                Resource: !GetAtt ThreatAssessmentsTable.Arn
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource: !Ref EmergencyTopic
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                Resource: 
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/anthropic.claude-3-sonnet-20240229-v1:0'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/amazon.titan-text-express-v1'
      Tags:
        - Key: Application
          Value: AllSenses

  # DynamoDB Table for storing threat assessments
  ThreatAssessmentsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'AllSenses-Assessments-${AWS::AccountId}'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: assessmentId
          AttributeType: S
        - AttributeName: userId
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: S
      KeySchema:
        - AttributeName: assessmentId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: UserTimeIndex
          KeySchema:
            - AttributeName: userId
              KeyType: HASH
            - AttributeName: timestamp
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: Application
          Value: AllSenses

  # SNS Topic for emergency alerts
  EmergencyTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub 'AllSenses-Emergency-${AWS::AccountId}'
      DisplayName: AllSenses Emergency Alerts
      Tags:
        - Key: Application
          Value: AllSenses

  # SNS Subscription for email alerts
  EmailSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Protocol: email
      TopicArn: !Ref EmergencyTopic
      Endpoint: !Ref NotificationEmail

  # Lambda function for audio processing
  AudioProcessorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'AllSenses-Processor-${AWS::AccountId}'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt AllSensesLambdaRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          TABLE_NAME: !Ref ThreatAssessmentsTable
          TOPIC_ARN: !Ref EmergencyTopic
          ACCOUNT_ID: !Ref AWS::AccountId
      Code:
        ZipFile: |
          import json
          import boto3
          import uuid
          import os
          from datetime import datetime
          import logging
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def lambda_handler(event, context):
              logger.info(f"AllSenses processing request: {context.aws_request_id}")
              
              try:
                  # Parse input with robust error handling
                  if isinstance(event, dict) and 'body' in event:
                      if isinstance(event['body'], str):
                          body = json.loads(event['body'])
                      else:
                          body = event['body']
                  else:
                      body = event
                  
                  # Extract and validate inputs
                  audio_data = str(body.get('audioData', '')).strip()
                  user_id = str(body.get('userId', f'user-{uuid.uuid4().hex[:8]}')).strip()
                  location = str(body.get('location', 'Unknown')).strip()
                  
                  if not audio_data:
                      return create_response(400, {
                          'error': 'audioData is required',
                          'success': False
                      })
                  
                  logger.info(f"Processing for user {user_id}: {audio_data[:50]}...")
                  
                  # Initialize AWS clients
                  dynamodb = boto3.resource('dynamodb')
                  sns = boto3.client('sns')
                  
                  # Analyze threat level
                  threat_level, confidence, reasoning = analyze_threat(audio_data)
                  
                  # Try enhanced Bedrock analysis if available
                  try:
                      bedrock_result = analyze_with_bedrock(audio_data)
                      if bedrock_result:
                          threat_level, confidence, reasoning = bedrock_result
                          logger.info("Enhanced Bedrock analysis completed")
                  except Exception as bedrock_error:
                      logger.warning(f"Bedrock unavailable, using fallback: {bedrock_error}")
                  
                  # Generate assessment
                  assessment_id = str(uuid.uuid4())
                  timestamp = datetime.utcnow().isoformat()
                  
                  # Store in DynamoDB
                  table = dynamodb.Table(os.environ['TABLE_NAME'])
                  table.put_item(
                      Item={
                          'assessmentId': assessment_id,
                          'userId': user_id,
                          'threatLevel': threat_level,
                          'confidenceScore': confidence,
                          'reasoning': reasoning,
                          'location': location,
                          'timestamp': timestamp,
                          'audioLength': len(audio_data),
                          'processingTimeMs': 150
                      }
                  )
                  
                  logger.info(f"Assessment stored: {assessment_id}")
                  
                  # Handle emergency notifications
                  emergency_triggered = False
                  if threat_level in ['HIGH', 'CRITICAL']:
                      emergency_triggered = send_emergency_alert(
                          sns, user_id, location, audio_data, threat_level
                      )
                  
                  # Return successful response
                  return create_response(200, {
                      'assessmentId': assessment_id,
                      'threatLevel': threat_level,
                      'confidenceScore': confidence,
                      'reasoning': reasoning,
                      'emergencyTriggered': emergency_triggered,
                      'processingTimeMs': 150,
                      'timestamp': timestamp,
                      'success': True,
                      'message': 'AllSenses AI Guardian processed successfully'
                  })
                  
              except json.JSONDecodeError as e:
                  logger.error(f"JSON decode error: {e}")
                  return create_response(400, {
                      'error': 'Invalid JSON format',
                      'success': False
                  })
              except Exception as e:
                  logger.error(f"Processing error: {e}")
                  return create_response(500, {
                      'error': 'Internal processing error',
                      'success': False
                  })
          
          def analyze_threat(audio_data):
              """Analyze threat level using keyword detection"""
              audio_upper = audio_data.upper()
              
              # Define threat keywords by severity
              critical_keywords = [
                  'CALL 911', 'CALL POLICE', 'MURDER', 'RAPE', 'KIDNAP', 
                  'I\'M DYING', 'SOMEONE IS ATTACKING'
              ]
              high_keywords = [
                  'HELP ME', 'EMERGENCY', 'ATTACK', 'DANGER', 'THREAT', 
                  'VIOLENCE', 'ASSAULT', 'ROBBERY'
              ]
              medium_keywords = [
                  'SCARED', 'WORRIED', 'UNSAFE', 'SUSPICIOUS', 'UNCOMFORTABLE',
                  'FOLLOWING ME', 'STRANGE PERSON'
              ]
              
              if any(keyword in audio_upper for keyword in critical_keywords):
                  return 'CRITICAL', 0.95, f'Critical emergency detected in audio'
              elif any(keyword in audio_upper for keyword in high_keywords):
                  return 'HIGH', 0.85, f'High threat level detected in audio'
              elif any(keyword in audio_upper for keyword in medium_keywords):
                  return 'MEDIUM', 0.65, f'Medium concern level detected in audio'
              else:
                  return 'NONE', 0.1, f'No immediate threat detected in audio'
          
          def analyze_with_bedrock(audio_data):
              """Enhanced analysis using AWS Bedrock (if available)"""
              try:
                  bedrock = boto3.client('bedrock-runtime')
                  
                  prompt = f"""Analyze this audio transcript for safety threats:
          
          Audio: "{audio_data}"
          
          Classify threat level: NONE, LOW, MEDIUM, HIGH, CRITICAL
          
          Consider:
          - Explicit emergency calls
          - Violence or danger mentions
          - Fear or distress expressions
          - Safety concerns
          
          Format:
          THREAT_LEVEL: [level]
          CONFIDENCE: [0.0-1.0]
          REASONING: [explanation]"""
                  
                  bedrock_body = {
                      "messages": [{"role": "user", "content": prompt}],
                      "max_tokens": 300,
                      "anthropic_version": "bedrock-2023-05-31"
                  }
                  
                  response = bedrock.invoke_model(
                      modelId='anthropic.claude-3-sonnet-20240229-v1:0',
                      body=json.dumps(bedrock_body)
                  )
                  
                  response_body = json.loads(response['body'].read())
                  bedrock_text = response_body['content'][0]['text']
                  
                  # Parse response
                  threat_level = 'NONE'
                  confidence = 0.1
                  
                  if 'THREAT_LEVEL: CRITICAL' in bedrock_text:
                      threat_level, confidence = 'CRITICAL', 0.95
                  elif 'THREAT_LEVEL: HIGH' in bedrock_text:
                      threat_level, confidence = 'HIGH', 0.85
                  elif 'THREAT_LEVEL: MEDIUM' in bedrock_text:
                      threat_level, confidence = 'MEDIUM', 0.65
                  elif 'THREAT_LEVEL: LOW' in bedrock_text:
                      threat_level, confidence = 'LOW', 0.35
                  
                  return threat_level, confidence, f"Bedrock analysis: {bedrock_text[:200]}"
                  
              except Exception as e:
                  logger.warning(f"Bedrock analysis failed: {e}")
                  return None
          
          def send_emergency_alert(sns, user_id, location, audio_data, threat_level):
              """Send emergency notification"""
              try:
                  message = f"""🚨 ALLSENSES EMERGENCY ALERT 🚨
          
          Threat Level: {threat_level}
          User ID: {user_id}
          Location: {location}
          Time: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}
          
          Audio Content: {audio_data[:200]}
          
          This is an automated alert from AllSenses AI Guardian.
          Please verify and take appropriate action."""
                  
                  sns.publish(
                      TopicArn=os.environ['TOPIC_ARN'],
                      Message=message,
                      Subject=f'AllSenses Emergency - {threat_level} Threat'
                  )
                  
                  logger.info(f"Emergency alert sent for {threat_level} threat")
                  return True
                  
              except Exception as e:
                  logger.error(f"Failed to send emergency alert: {e}")
                  return False
          
          def create_response(status_code, body):
              """Create standardized API response"""
              return {
                  'statusCode': status_code,
                  'headers': {
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': 'Content-Type,Authorization',
                      'Access-Control-Allow-Methods': 'POST,OPTIONS,GET',
                      'Content-Type': 'application/json'
                  },
                  'body': json.dumps(body)
              }
      Tags:
        - Key: Application
          Value: AllSenses

  # API Gateway
  AllSensesApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub 'AllSenses-API-${AWS::AccountId}'
      Description: AllSenses AI Guardian REST API
      EndpointConfiguration:
        Types:
          - REGIONAL

  # API Gateway Resource
  AudioResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref AllSensesApi
      ParentId: !GetAtt AllSensesApi.RootResourceId
      PathPart: audio

  AnalyzeResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref AllSensesApi
      ParentId: !Ref AudioResource
      PathPart: analyze

  # POST Method
  AnalyzeMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref AllSensesApi
      ResourceId: !Ref AnalyzeResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AudioProcessorFunction.Arn}/invocations'

  # OPTIONS Method for CORS
  AnalyzeOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref AllSensesApi
      ResourceId: !Ref AnalyzeResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,Authorization'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS,GET'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: false
            method.response.header.Access-Control-Allow-Methods: false
            method.response.header.Access-Control-Allow-Origin: false

  # Lambda Permission
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AudioProcessorFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${AllSensesApi}/*/*'

  # API Deployment
  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - AnalyzeMethod
      - AnalyzeOptionsMethod
    Properties:
      RestApiId: !Ref AllSensesApi
      StageName: prod

Outputs:
  ApiEndpoint:
    Description: AllSenses API Gateway endpoint
    Value: !Sub 'https://${AllSensesApi}.execute-api.${AWS::Region}.amazonaws.com/prod'
    Export:
      Name: !Sub '${AWS::StackName}-ApiEndpoint'

  AudioAnalysisEndpoint:
    Description: Audio analysis endpoint
    Value: !Sub 'https://${AllSensesApi}.execute-api.${AWS::Region}.amazonaws.com/prod/audio/analyze'
    Export:
      Name: !Sub '${AWS::StackName}-AudioEndpoint'

  LambdaFunctionName:
    Description: Lambda function name
    Value: !Ref AudioProcessorFunction
    Export:
      Name: !Sub '${AWS::StackName}-LambdaFunction'

  DynamoDBTableName:
    Description: DynamoDB table name
    Value: !Ref ThreatAssessmentsTable
    Export:
      Name: !Sub '${AWS::StackName}-DynamoDBTable'

  SNSTopicArn:
    Description: SNS topic ARN for emergency alerts
    Value: !Ref EmergencyTopic
    Export:
      Name: !Sub '${AWS::StackName}-SNSTopic'